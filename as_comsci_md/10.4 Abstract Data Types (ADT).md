# 10.4 Abstract Data Types (ADTs)
=> Describe a data structure and a collection of operations that can be used on data with the datatype

- operators often include:
	- create instance
	- find element
	- insert new element
	- delete element
	- and sometimes: -show all data

## Common Abstract Data Types

| Stack                               | Queue                             | Linked List                               |
| ----------------------------------- | --------------------------------- | ----------------------------------------- |
| Last-in-first-out (LIFO)*           | First-in-first-out (FIFO)*        | A list where one item points to the next  |
| e.g. stack of CDs                   | e.g. toilet queue                 | e.g. browser link history                 |

\*LIFO = The last (most recent) item in is the first one out
\*FIFO = The first item in is the first item out

## Stacks
- Items can be pushed (added) to the stack
- Items can be popped (removed) from the stack

| Index | Value | Pointer |
| :---: | :---: | :--- |
| 5     |       | |
| 4     | 8     | <-- TopOfStackPointer |
| 3     | 5     | |
| 2     | 6     | |
| 1     | 42    | |
| 0     | 1     | <-- BaseOfStackPointer |

- The TopOfStackPointer always follows the position of the newest element
- The BaseOfStackPointer always points to the first slot

| Index | Value | Pointer |
| :---: | :---: | :--- |
| 3     |       | |
| 2     |       | |
| 1     |       | |
| 0     |       | <-- BaseOfStackPointer at 0 |
| -1    |       | <-- TopOfStackPointer at -1 |

- as the BaseOfStackPointer always remains at zero, the top of stack pointer will have to move to -1 to show an empty stack. Zero doesn't work

## Queues
| Index | Value | Pointer |
| :---: | :---: | :--- |
| 0     | A     | <-- FrontOfQueuePointer |
| 1     | B     | |
| 2     | C     | <-- EndOfQueuePointer |
| 3     |       | |
| 4     |       | |

An empty queue where `Front/EndOfQueuePointer` = `(-1)`
This indicates that there is no item in the queue, 0 and 0 would mean there is one item.

when item leaves Front:
*Before:*
| Index | Value |
| :---: | :---: |
| 0     | A     |
| 1     | B     |
| 2     | C     |

*After (all items have to move up):*
| Index | Value | Pointer |
| :---: | :---: | :--- |
| 0     | B     | <-- FrontOfQueuePointer |
| 1     | C     | <-- EndOfQueuePointer |
| 2     |       | |

- Items are enqueued and dequeued

### Circular Queues
*Initial State:*
A circular queue with 5 slots (0-4).
- `FrontOfQueue-Pointer` (Front) is at index 1 (value 3).
- `EndOfQueuePointer` (Rear) is at index 2 (value 6).

*Adding 8:*
- Element 8 is added at the next available rear slot (index 3).
- `EndOfQueuePointer` now points to index 3.

*Dequeue 1:*
- The element at the front (value 3 at index 1) is removed.
- `FrontOfQueue-Pointer` now points to the next element at index 2 (value 6).

*Add 1, 2:*
- Element 1 is added. The `EndOfQueuePointer` wraps around and points to index 4.
- Element 2 is added. The `EndOfQueuePointer` wraps around and points to index 0.

## Linked Lists
- elements can be stored in any free memory location, they aren't required to be consecutive
- the list consists of many nodes
- each node consists of data and a memory address

**Example node:**
`[ key field | pointer -> ]`
"key" refers to the data stored.
The pointer is the memory address of the next node.
* a node usually contains much more than just one variable
-> usually contains record

**Example List:**
`Start Pointer -> [ variable | ptr ] -> [ Var | ptr ] -> [ Var | ∅ ]`
The last pointer is a `null pointer` -> doesn't point to anything.

### Benefits of Linked Lists
- unlike with arrays, it's incredibly efficient to insert and delete nodes, as the nodes aren't stored in consecutive order in memory

### Weaknesses of Linked Lists
- search / sorting:
	- simpler linked list types only allow to progress in one direction
	- there is no index, each node has to be traced!
- More storage is needed for the pointers

### Insertion & Deletion

**Deletion:**
*Before:* `[ A | Addr. B ] -> [ B | Addr. C ] -> [ C | ... ]`
To delete B, the pointer of node A is changed to point to C.
*After:* `[ A | Addr. C ] -> [ C | ... ]`

**Insertion:**
*Before:* `[ A | Addr. C ] -> [ C | ... ]`
To insert node Q between A and C, node A's pointer is updated to point to Q, and node Q's pointer is set to point to C.
*After:* `[ A | Addr. Q ] -> [ Q | Addr. C ] -> [ C | ... ]`

## Implementing Linked Lists with Arrays :
=> Two arrays are used to store the nodes
- One array stores the data, the other one the pointer
- a node consists of two list elements with the same index
- the value of the start pointer has also to be stored

| StartPointer |
| :----------: |
| 1 |

| Data      | Index | Pointer |
| :-------- | :---: | :-----: |
| "like"    | 0     | 2       |
| "I"       | 1     | 0       |
| "apples"  | 2     | 3       |
| "very"    | 3     | 4       |
| "much"    | 4     | -1      |
|           | 5     |         |
|           | 6     |         |
|           | 7     |         |
`<- -1` acts as null pointer (∅)

**Deletion:**
- The removed node remains in the array but it's inaccessible as no pointer is pointing to it.
- The deleted node can still have a pointer itself

=> Free lists should be created with all free (deleted) nodes

## Free Lists
=> Unused nodes have to be easy to find so that they can be reused
- all free nodes including the deleted ones will be appended to the free list

**Empty Linked List:**
=> All elements are part of the free list

| StartPointer |
| :----------: |
| -1           |

| FreeListPointer |
| :-------------: |
| 0               |

| Data | Index | Pointer |
| :--- | :---: | :-----: |
|      | 0     | 1       |
|      | 1     | 2       |
|      | 2     | 3       |
|      | 3     | 4       |
|      | 4     | 5       |
|      | 5     | 6       |
|      | 6     | 7       |
|      | 7     | 8       |

**Partially filled Linked + Free List:**

| StartPointer |
| :----------: |
| 0            |

| FreeListPointer |
| :-------------: |
| 2               |

| Data | Index | Pointer |
| :--- | :---: | :-----: |
| 42   | 0     | 1       |
| 420  | 1     | 3       |
|      | 2     | 4       |
| 90   | 3     | -1      |
|      | 4     | 5       |
|      | 5     | 6       |
|      | 6     | 7       |
|      | 7     | -1      |

Two null pointers are present in the pointer list.