# 4.4 Fetch-Execute (F-E) Cycle

## The Fetch-Execute Cycle Flowchart
1.  **START**
2.  **Check**: Any instructions to execute?
    *   **NO**: Loop back to check again.
    *   **YES**: Proceed to Fetch.
3.  **Fetch**: Fetch next instruction.
4.  **Decode**: Decode instruction.
5.  **Execute**: Execute instruction.
6.  **Check for Interrupts**: Any interrupts to be processed?
    *   **NO**: Loop back to step 2 (Check for instructions).
    *   **YES**: Transfer control to interrupt handling program, then loop back to step 2 (Check for instructions).

---

## Example when program already running: 
(each point one cycle)
*   (Program counter already stored next address)
*   address from PC copied to MAR
*   At the same time:
    *   data at address in MAR is fetched into MDR
    *   PC is incremented
*   Instruction stored in MDR is transferred to CIR
*   Instruction is interpreted by CU and ALU might be activated if arithmetic is involved

## Note:
*   The system clock is used, as data from outside the processor is fetched.
*   PC isn't always simply incremented: e.g. when there is a 'jump' instruction then an entirely different address might be loaded.

## Register transfer notation
*   describes operations between registers
*   e.g. the fetch part of the F-E cycle

$$MAR \leftarrow [PC]$$
$$PC \leftarrow [PC] + 1; MDR \leftarrow [[MAR]]$$
$$CIR \leftarrow [MDR]$$

## Notation:
*   first item is data destination
*   abbreviations are used (e.g. MAR)
*   second item is the data's definition (where it came from)
*   square brackets indicate a register's data is being moved
*   arrow underlines flow of data
*   tasks separated by a semicolon happen at the same time
*   The double brackets mean that not the address in MAR but the data at the address in MAR is being transferred.

## Interrupt handling
*   some reasons for interrupts:
    *   fatal error
    *   user interaction
    *   need to start I/O processing
    *   a timer signal
    *   hardware fault
*   interrupts have different priorities
*   some interrupts will erase the current process, others just pause it
*   a way for the processor to identify the type of interrupt would be an 'interrupt register' (IR)
    *   -> works similar to status register with flags.

### how interrupts are handled:
*   content of program counter and other registers saved to memory
*   an 'interrupt service routine' (ISR) is chosen according to the problem.
    *   -> start address loaded into PC
*   at end of execution, check if there are still other interrupts
*   further interrupts are processed
*   if no interrupts, load original data from memory, resume
